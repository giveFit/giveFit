"use strict";
var react_1 = require('react');
var ReactDOM = require('react-dom/server');
var assign = require('object-assign');
var flatten = require('lodash.flatten');
function getPropsFromChild(child) {
    var props = child.props, type = child.type;
    var ownProps = assign({}, props);
    if (type && type.defaultProps)
        ownProps = assign({}, type.defaultProps, props);
    return ownProps;
}
exports.getPropsFromChild = getPropsFromChild;
function getChildFromComponent(component) {
    if (component && component.render)
        return component.render();
    return component;
}
exports.getChildFromComponent = getChildFromComponent;
function getQueriesFromTree(_a, fetch) {
    var component = _a.component, _b = _a.context, context = _b === void 0 ? {} : _b, _c = _a.queries, queries = _c === void 0 ? [] : _c;
    if (fetch === void 0) { fetch = true; }
    if (!component)
        return;
    if (typeof component === 'function')
        component = { type: component };
    var type = component.type, props = component.props;
    if (typeof type === 'function') {
        var ComponentClass = type;
        var ownProps = getPropsFromChild(component);
        var Component = new ComponentClass(ownProps, context);
        try {
            Component.props = ownProps;
        }
        catch (e) { }
        if (Component.componentWillMount)
            Component.componentWillMount();
        var newContext = context;
        if (Component.getChildContext)
            newContext = assign({}, context, Component.getChildContext());
        context = newContext;
        if (typeof type.fetchData === 'function' && fetch) {
            var query = type.fetchData(ownProps, newContext);
            if (query)
                queries.push({ query: query, component: component });
        }
        getQueriesFromTree({
            component: getChildFromComponent(Component),
            context: newContext,
            queries: queries,
        });
    }
    else if (props && props.children) {
        react_1.Children.forEach(props.children, function (child) { return getQueriesFromTree({
            component: child,
            context: context,
            queries: queries,
        }); });
    }
    return { queries: queries, context: context };
}
function getDataFromTree(app, ctx, fetch) {
    if (ctx === void 0) { ctx = {}; }
    if (fetch === void 0) { fetch = true; }
    var _a = getQueriesFromTree({ component: app, context: ctx }, fetch), context = _a.context, queries = _a.queries;
    if (!queries.length)
        return Promise.resolve(context);
    var mappedQueries = flatten(queries).map(function (y) { return y.query.then(function (x) { return y; }); });
    return Promise.all(mappedQueries)
        .then(function (trees) { return Promise.all(trees.filter(function (x) { return !!x; }).map(function (x) {
        return getDataFromTree(x.component, context, false);
    })); })
        .then(function () { return (context); });
}
exports.getDataFromTree = getDataFromTree;
function renderToStringWithData(component) {
    return getDataFromTree(component)
        .then(function (_a) {
        var store = _a.store, client = _a.client;
        var markup = ReactDOM.renderToString(component);
        var initialState = store.getState();
        var key = client.reduxRootKey;
        for (var queryId in initialState[key].queries) {
            var fieldsToNotShip = ['minimizedQuery', 'minimizedQueryString'];
            for (var _i = 0, fieldsToNotShip_1 = fieldsToNotShip; _i < fieldsToNotShip_1.length; _i++) {
                var field = fieldsToNotShip_1[_i];
                delete initialState[key].queries[queryId][field];
            }
        }
        initialState = encodeURI(JSON.stringify(initialState));
        var payload = "<script>window.__APOLLO_STATE__ = \"" + initialState + "\";</script>";
        markup += payload;
        return markup;
    });
}
exports.renderToStringWithData = renderToStringWithData;
//# sourceMappingURL=server.js.map